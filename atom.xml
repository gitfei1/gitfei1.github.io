<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>不知道的博客</title>
  
  
  <link href="https://gitfei1.github.io/atom.xml" rel="self"/>
  
  <link href="https://gitfei1.github.io/"/>
  <updated>2024-08-07T01:15:40.740Z</updated>
  <id>https://gitfei1.github.io/</id>
  
  <author>
    <name>不知道</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Nats基础</title>
    <link href="https://gitfei1.github.io/Nats%E5%9F%BA%E7%A1%80/"/>
    <id>https://gitfei1.github.io/Nats%E5%9F%BA%E7%A1%80/</id>
    <published>2024-08-05T11:17:33.000Z</published>
    <updated>2024-08-07T01:15:40.740Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Nats"><a href="#Nats" class="headerlink" title="Nats"></a>Nats</h2><ol><li>高性能、简单、安全</li><li>超过30中语言支持的客户端</li><li>CNCF项目</li><li>实时数据流场景适用</li><li>易于开发运维。</li><li>不到20MB</li><li><a href="https://nats.io/">https://nats.io/</a></li></ol><h2 id="两种模式"><a href="#两种模式" class="headerlink" title="两种模式"></a>两种模式</h2><ul><li><p>core Nats 的服务质量是最多发送一次  fire and forget （发送并且忘记）,它仅会将消息保留在内存中，永远不会直接将消息写入磁盘，不持久化。</p></li><li><p>JetStream：当你用到持久化、key&#x2F;value存储、最少发送一次、精确发送一次等功能时，手动打开内置的JetStream功能。</p></li></ul><h2 id="Linux安装Nats"><a href="#Linux安装Nats" class="headerlink" title="Linux安装Nats"></a>Linux安装Nats</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install -y unzip</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载二进制文件</span></span><br><span class="line">curl -L https://github.com/nats-io/nats-server/releases/download/v<span class="variable">$VERSION</span>/nats-server-v<span class="variable">$VERSION</span>-linux-amd64.zip -o nats-server.zip</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解压</span></span><br><span class="line">unzip nats-server.zip</span><br><span class="line"></span><br><span class="line"><span class="comment"># 放到/usr/local/bin/ 并且添加执行权限</span></span><br><span class="line">sudo <span class="built_in">mv</span> nats-server-v<span class="variable">$VERSION</span>-linux-amd64/nats-server /usr/local/bin/  </span><br><span class="line">sudo <span class="built_in">chmod</span> +x /usr/local/bin/nats-server</span><br><span class="line"></span><br><span class="line"><span class="comment"># 清理临时文件</span></span><br><span class="line"><span class="built_in">rm</span> -rf nats-server.zip nats-server-v<span class="variable">$VERSION</span>-linux-amd64</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动 NATS 服务器</span></span><br><span class="line">nats-server &amp;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装Cli 工具</span></span><br><span class="line">curl -sf https://binaries.nats.dev/nats-io/natscli/nats@latest | sh</span><br><span class="line"><span class="built_in">chmod</span> +x nats  </span><br><span class="line">sudo <span class="built_in">mv</span> nats /usr/local/bin/</span><br></pre></td></tr></table></figure><h2 id="Subject"><a href="#Subject" class="headerlink" title="Subject"></a>Subject</h2><ul><li><p>其他队列系统的主题关键词</p><p>  <code>Subjects</code>  <code>topics</code>, <code>channels</code>, <code>streams</code></p></li><li><p>subject 的特点</p><p>  消息会自动发送给所有感兴趣的订阅者，无论他们在哪里。<br>  没有订阅者的主题消息会自动被丢弃（有关消息持久化的详细信息，请查看 JetStream 功能）。</p></li></ul><p><img src="/Nats%E5%9F%BA%E7%A1%80/subject.png" alt="img"></p><ul><li><p>subject 通配符</p><p>第一个通配符是  * ，可以匹配一个单独的标记，可以出现多次。例如，如果一个应用程序想要监听东部时区，它可以订阅 time.<em>.east，这样就可以匹配 time.us.east 和 time.eu.east。注意，   * 不能匹配标记中的子字符串，比如 time.New</em>.east。</p><p><img src="/Nats%E5%9F%BA%E7%A1%80/wildcard1.png" alt="img"></p><p>第二个通配符是 &gt;，它可以匹配一个或多个标记，并且只能出现在主题的末尾。例如，time.us.&gt; 会匹配 time.us.east 和 time.us.east.atlanta，而 time.us.* 只能匹配 time.us.east，因为它无法匹配多个标记。单独订阅一个subject为<code>&gt;</code>的会接收所有主题的消息。<br><img src="/Nats%E5%9F%BA%E7%A1%80/wildcard2.png" alt="img"></p></li><li><p>subject 的数量</p><p>  NATS可以高效地管理数千万个主题，因此你可以为你的业务实体使用细粒度的地址。主题是短暂的资源，当没有人订阅时，它们会消失。<br>  不过，主题订阅需要服务器将其缓存到内存中。考虑到当你订阅的主题数量超过一百万时，你将需要超过1GB的服务器内存，而且这个需求将线性增长。</p></li></ul><h2 id="Publish-Subscribe"><a href="#Publish-Subscribe" class="headerlink" title="Publish-Subscribe"></a>Publish-Subscribe</h2><ul><li>fan-out模型<br><img src="/Nats%E5%9F%BA%E7%A1%80/fan-out%E6%A8%A1%E5%9E%8B.png" alt="img"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nats sub msg.test</span><br><span class="line">nats pub msg.test &quot;NATS MESSAGE&quot;</span><br></pre></td></tr></table></figure></li></ul><h2 id="message"><a href="#message" class="headerlink" title="message"></a>message</h2><pre><code>消息具有最大大小（在服务器配置中使用 max_payload 设置）。默认情况下，大小设置为 1 MB，但如果需要，可以增加到 64 MB（尽管我们建议将最大消息大小保持在更合理的值，例如 8 MB）。</code></pre><h2 id="Request-Reply"><a href="#Request-Reply" class="headerlink" title="Request-Reply"></a>Request-Reply</h2><p><img src="/Nats%E5%9F%BA%E7%A1%80/request_reply.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nats reply help.please &#x27;OK, I CAN HELP!!!</span><br><span class="line"></span><br><span class="line">nats request help.please &#x27;I need help!</span><br></pre></td></tr></table></figure><h2 id="Queue-Groups"><a href="#Queue-Groups" class="headerlink" title="Queue Groups"></a>Queue Groups</h2><p>多个消费者并行消费消息,一条消息只能被一个消费者消费。<br><img src="/Nats%E5%9F%BA%E7%A1%80/queue-group.png" alt="img"></p><h1 id="JetStream"><a href="#JetStream" class="headerlink" title="JetStream"></a>JetStream</h1><ul><li>可以对消息做持久化</li><li>实现精确一次QOS</li><li>使用 K&#x2F;V store 、Object Store</li><li>source 和 mirror 实现replication</li></ul><h2 id="StorageType"><a href="#StorageType" class="headerlink" title="StorageType"></a>StorageType</h2><ul><li><code>File</code> (default)</li><li><code>Memory</code></li></ul><h2 id="RetentionPolicy"><a href="#RetentionPolicy" class="headerlink" title="RetentionPolicy"></a>RetentionPolicy</h2><ul><li><p><code>LimitsPolicy</code> (default)<br>  <code>MaxMsgs</code>, <code>MaxBytes</code>, <code>MaxAge</code>, and <code>MaxMsgsPerSubject</code><br>  如果设置了这些限制中的任何一个，则无论先达到哪个限制都将导致相应消息的自动删除。<br>  官网代码样例  <a href="https://natsbyexample.com/examples/jetstream/limits-stream/go">https://natsbyexample.com/examples/jetstream/limits-stream/go</a></p></li><li><p><code>InterestPolicy</code><br>  如果没有消费者对stream感兴趣，那stream收到一条消息立即被删除。<br>  只有所有的消费者都回复ACK，stream的消息才会被删除<br>  如果消费者设置了<code>FilterSubject: &quot;events.mouse_clicked&quot;</code>，不会对其他主题感兴趣。<br>  官网代码样例 <a href="https://natsbyexample.com/examples/jetstream/interest-stream/go">https://natsbyexample.com/examples/jetstream/interest-stream/go</a></p></li><li><p><code>WorkQueuePolicy</code><br>  工作队列，FIFO模型，一条消息只能被一个消费者消费到。这是通过只允许为工作队列流创建<strong>一个使用者</strong>来强制执行的。一旦消息ACK，就被删除。</p></li></ul><h2 id="DiscardPolicy"><a href="#DiscardPolicy" class="headerlink" title="DiscardPolicy"></a>DiscardPolicy</h2><p>The discard behavior applies only for streams that have at least one limit defined. The options include:</p><ul><li><p><code>DiscardOld</code> (default) -  the oldest messages in order to maintain the limit. For example, if <code>MaxAge</code> is set to one minute, the server will automatically delete messages older than one minute with this policy.</p></li><li><p><code>DiscardNew</code> - This policy will reject <em>new</em> messages from being appended to the stream if it would <em>exceed</em> one of the limits. An extension to this policy is <code>DiscardNewPerSubject</code> which will apply this policy on a per-subject basis within the stream.</p></li></ul><p>只有设置了limit，才会有Discard行为。</p><ul><li>默认DiscardOld策略，例如：设置了MaxAge为1分钟，Nats服务会自动删除生命周期超过1分钟的Messages</li><li>DiscardNew 策略会自动拒绝超过 limit 设置的新Messages。</li><li>DiscardNewPerSubject 策略会将DiscardNew 应用到stream的每个subject。</li></ul><h2 id="基础指令"><a href="#基础指令" class="headerlink" title="基础指令"></a>基础指令</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看Nats 信息</span></span><br><span class="line">nats account info</span><br><span class="line"></span><br><span class="line"><span class="comment"># 看到下列字样代表没有开启JetStream</span></span><br><span class="line">JetStream is not supported <span class="keyword">in</span> this account</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如何开启JetStream</span></span><br><span class="line">停止 nats-server 并且启动 nats-server -js </span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建Stream</span></span><br><span class="line">nats stream add my_stream</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看stream 信息</span></span><br><span class="line">nats stream info my_stream</span><br><span class="line"></span><br><span class="line"><span class="comment"># Publish some messages into the stream</span></span><br><span class="line">nats pub foo --count=1000 --<span class="built_in">sleep</span> 1s <span class="string">&quot;publication #&#123;&#123;Count&#125;&#125; @ &#123;&#123;TimeStamp&#125;&#125;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看发布的messages</span></span><br><span class="line">nats stream view my_stream</span><br><span class="line">nats stream info my_stream</span><br><span class="line">watch <span class="string">&quot;nats stream info my_stream&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#创建消费者</span></span><br><span class="line">nats consumer add</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动消费</span></span><br><span class="line">nats consumer next my_stream pull_consumer --count 1000</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看消费者信息</span></span><br><span class="line">nats consumer info</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除消费者</span></span><br><span class="line">nats consumer <span class="built_in">rm</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 您可以使用`nats stream purge`清理流（并释放与其关联的资源（例如存储在流中的消息））</span></span><br><span class="line">nats stream purge</span><br><span class="line"></span><br><span class="line"><span class="comment"># 您还可以使用`nats stream rm`删除流（这也会自动删除可能在该流上定义的所有消费者）</span></span><br><span class="line">nats stream <span class="built_in">rm</span></span><br></pre></td></tr></table></figure><h2 id="Key-Value-Store"><a href="#Key-Value-Store" class="headerlink" title="Key&#x2F;Value Store"></a>Key&#x2F;Value Store</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 要在JetStream模式下</span></span><br><span class="line">nats account info</span><br><span class="line"></span><br><span class="line"><span class="comment">#Creating a KV bucket</span></span><br><span class="line">nats kv add my-kv</span><br><span class="line"></span><br><span class="line"><span class="comment">#Storing a value</span></span><br><span class="line">nats kv put my-kv Key1 Value1</span><br><span class="line"></span><br><span class="line"><span class="comment">#Getting a value</span></span><br><span class="line">nats kv get my-kv Key1</span><br><span class="line"></span><br><span class="line"><span class="comment">#Deleting a value</span></span><br><span class="line">nats kv del my-kv Key1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 支持并发模式</span></span><br><span class="line">Atomic operations</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Nats&quot;&gt;&lt;a href=&quot;#Nats&quot; class=&quot;headerlink&quot; title=&quot;Nats&quot;&gt;&lt;/a&gt;Nats&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;高性能、简单、安全&lt;/li&gt;
&lt;li&gt;超过30中语言支持的客户端&lt;/li&gt;
&lt;li&gt;CNCF项目&lt;/li&gt;
&lt;l</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>json解析方式对比测试</title>
    <link href="https://gitfei1.github.io/json%E8%A7%A3%E6%9E%90%E6%96%B9%E5%BC%8F%E5%AF%B9%E6%AF%94%E6%B5%8B%E8%AF%95/"/>
    <id>https://gitfei1.github.io/json%E8%A7%A3%E6%9E%90%E6%96%B9%E5%BC%8F%E5%AF%B9%E6%AF%94%E6%B5%8B%E8%AF%95/</id>
    <published>2024-03-07T03:01:23.000Z</published>
    <updated>2024-03-07T03:02:34.704Z</updated>
    
    <content type="html"><![CDATA[<p>解析方法代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;encoding/json&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    jsoniter <span class="string">&quot;github.com/json-iterator/go&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    str <span class="type">string</span> = <span class="string">`&#123;</span></span><br><span class="line"><span class="string">&quot;state&quot;: true,</span></span><br><span class="line"><span class="string">&quot;timestamp&quot;: 1703043543633,</span></span><br><span class="line"><span class="string">&quot;data&quot;: [</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">&quot;id&quot;: 3,</span></span><br><span class="line"><span class="string">&quot;value&quot;: &quot;正常&quot;</span></span><br><span class="line"><span class="string">&#125;,</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">&quot;id&quot;: 510008620,</span></span><br><span class="line"><span class="string">&quot;value&quot;: &quot;告警&quot;</span></span><br><span class="line"><span class="string">&#125;,</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">&quot;id&quot;: 510009040,</span></span><br><span class="line"><span class="string">&quot;value&quot;: &quot;告警&quot;</span></span><br><span class="line"><span class="string">&#125;,</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">&quot;id&quot;: 510018310,</span></span><br><span class="line"><span class="string">&quot;value&quot;: &quot;告警&quot;</span></span><br><span class="line"><span class="string">&#125;,</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">&quot;id&quot;: 510018920,</span></span><br><span class="line"><span class="string">&quot;value&quot;: &quot;告警&quot;</span></span><br><span class="line"><span class="string">&#125;,</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">&quot;id&quot;: 510001370,</span></span><br><span class="line"><span class="string">&quot;value&quot;: &quot;告警&quot;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">],</span></span><br><span class="line"><span class="string">&quot;err_msg&quot;: null,</span></span><br><span class="line"><span class="string">&quot;err_code&quot;: &quot;0&quot;</span></span><br><span class="line"><span class="string">&#125;`</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">var</span> dataInfoPool = sync.Pool&#123;</span><br><span class="line">    New: <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="keyword">interface</span>&#123;&#125; &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">new</span>(DataInfo)</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//标准库json</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">JsonParse</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> info DataInfo</span><br><span class="line">    <span class="keyword">if</span> err := json.Unmarshal([]<span class="type">byte</span>(str), &amp;info); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;err&quot;</span>, err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//对象池</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">JsonParsePool</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//var info DataInfo</span></span><br><span class="line">    info := dataInfoPool.Get().(*DataInfo)</span><br><span class="line">    <span class="keyword">if</span> err := json.Unmarshal([]<span class="type">byte</span>(str), info); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;err&quot;</span>, err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    dataInfoPool.Put(info)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Jsoniter</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">JsoniterParse</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> info DataInfo</span><br><span class="line">    err := jsoniter.Unmarshal([]<span class="type">byte</span>(str), &amp;info)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;unmarshal error: &quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Jsoniter+对象池</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">JsoniterParseMerge</span><span class="params">()</span></span> &#123;</span><br><span class="line">    info := dataInfoPool.Get().(*DataInfo)</span><br><span class="line">    err := jsoniter.Unmarshal([]<span class="type">byte</span>(str), &amp;info)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;unmarshal error: &quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    dataInfoPool.Put(info)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> DataInfo <span class="keyword">struct</span> &#123;</span><br><span class="line">    State     <span class="type">bool</span>  <span class="string">`json:&quot;state&quot;`</span></span><br><span class="line">    Timestamp <span class="type">int64</span> <span class="string">`json:&quot;timestamp&quot;`</span></span><br><span class="line">    Data      []<span class="keyword">struct</span> &#123;</span><br><span class="line">        Signalid <span class="type">int</span>    <span class="string">`json:&quot;signalid&quot;`</span></span><br><span class="line">        Value    <span class="type">string</span> <span class="string">`json:&quot;value&quot;`</span></span><br><span class="line">    &#125; <span class="string">`json:&quot;data&quot;`</span></span><br><span class="line">    ErrMsg  <span class="keyword">interface</span>&#123;&#125; <span class="string">`json:&quot;err_msg&quot;`</span></span><br><span class="line">    ErrCode <span class="type">string</span>      <span class="string">`json:&quot;err_code&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写Benchmark，启动测试</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;testing&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkJsonParse</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">JsonParse()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkJsonParsePoole</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">JsonParsePool()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkJsoniterParse</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">JsoniterParse()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkJsoniterParseMerge</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">JsoniterParseMerge()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果</p><p><img src="/json%E8%A7%A3%E6%9E%90%E6%96%B9%E5%BC%8F%E5%AF%B9%E6%AF%94%E6%B5%8B%E8%AF%95/benchmark.png" alt="img"></p><p>结论：</p><ol><li>标准库json解析最慢，运行时间6159ns，内存占用最多1312B</li><li>采用对象池，内存占用下降明显30%，但是执行时间下降7%</li><li>采用Jsoniter，内存占用下降明显30%，执行时间下降70%。</li><li>采用对象池+Jsoniter，内存占用下降60%，执行时间下降80%</li><li>json解析频繁情况下，可以采用<strong>对象池+Jsoniter</strong></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;解析方法代码&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Linux环境变量加载顺序分析</title>
    <link href="https://gitfei1.github.io/Linux%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E5%8A%A0%E8%BD%BD%E9%A1%BA%E5%BA%8F%E5%88%86%E6%9E%90/"/>
    <id>https://gitfei1.github.io/Linux%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E5%8A%A0%E8%BD%BD%E9%A1%BA%E5%BA%8F%E5%88%86%E6%9E%90/</id>
    <published>2024-03-06T03:14:34.000Z</published>
    <updated>2024-03-06T03:15:08.331Z</updated>
    
    <content type="html"><![CDATA[<p>参考连接 <a href="https://cloud.tencent.com/developer/article/2097050">https://cloud.tencent.com/developer/article/2097050</a></p><p><strong>&#x2F;etc&#x2F;profile是系统级的配置文件，而~&#x2F;.bash_profile是用户级的配置文件</strong>。 它们的作用范围和加载顺序不同，用户可以根据自己的需求在这两个文件中定义和修改配置。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@w2 ~]# cat ~/.bash_profile | grep TEST</span><br><span class="line">export TEST=111</span><br><span class="line">[root@w2 ~]# cat /etc/profile | grep TEST</span><br><span class="line">export TEST=222</span><br><span class="line">[root@w2 ~]# env | grep TEST</span><br><span class="line">TEST=111</span><br></pre></td></tr></table></figure><ol><li>设置同一个环境变量TEST，在用户配置文件中设置为111，在系统配置文件设置为222。</li><li>先应用用户配置文件 source ~&#x2F;.bash_profile，通过env | grep TEST看到成功改为111.</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@w2 ~]# cat test.sh </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">echo $TEST</span><br><span class="line">[root@w2 ~]# </span><br><span class="line">[root@w2 ~]# cat env.sh</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">source /etc/profile</span><br><span class="line">echo $TEST</span><br><span class="line">[root@w2 ~]# </span><br></pre></td></tr></table></figure><ol><li>编写test.sh脚本读取环境变量TEST</li><li>在env.sh先应用&#x2F;etc&#x2F;profile，在读取TEST</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@w2 ~]# ./test.sh </span><br><span class="line">111</span><br><span class="line">[root@w2 ~]# ./env.sh </span><br><span class="line">222</span><br><span class="line">[root@w2 ~]# env | grep TEST</span><br><span class="line">TEST=111</span><br></pre></td></tr></table></figure><ol><li>执行两个脚本并查看当前TEST值。</li></ol><p>结论：</p><ol><li>shell脚本执行直接读取env看到的环境变量值</li><li>如果脚本中执行source &#x2F;etc&#x2F;profile，会临时覆盖env中的环境变量，此时读取到&#x2F;etc&#x2F;profile中的值。</li><li>脚本退出后，env查看TEST变量未被修改。</li></ol><p>用法：</p><ol><li>&#x2F;etc&#x2F;profile文件就存放系统的环境变量，应用到全局。</li><li>~&#x2F;.bash_profile文件就存放用户的环境变量。</li><li>写shell 脚本的时候都应用一下 source &#x2F;etc&#x2F;profile  source ~&#x2F;.bash_profile</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;参考连接 &lt;a href=&quot;https://cloud.tencent.com/developer/article/2097050&quot;&gt;https://cloud.tencent.com/developer/article/2097050&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>wireshark使用</title>
    <link href="https://gitfei1.github.io/wireshark%E4%BD%BF%E7%94%A8/"/>
    <id>https://gitfei1.github.io/wireshark%E4%BD%BF%E7%94%A8/</id>
    <published>2024-02-29T11:12:53.000Z</published>
    <updated>2024-02-29T11:13:32.640Z</updated>
    
    <content type="html"><![CDATA[<p>Wireshark 的主界面还有个特点，就是当它的 Information 列展示的是应用层信息时，这个报文的 TCP 层面的控制信息就不显示了。</p><p>第一个 FIN 控制报文，并没有像常规的那样单独出现，而是合并（Piggybacking）在 POST 报文里！</p><hr><p>TTL 的值是反映了网络路径跳数的，也可以通过它间接推导出对端的 OS 类型。不同的操作系统其初始 TTL 值不同，一般来说 Windows 是 128，Linux 是 64。</p><p>因为内网路径相对稳定，一般不会变化。如果出现 TTL 值的波动，特别是当这个波动值比较大（比如超过 2）的时候，那几乎就说明这些包的不同寻常了。这就是我想说的第二点：<strong>内网同一个连接中的报文，其 TTL 值一般不会变化。</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">抓取IP层的报文</span></span><br><span class="line">tcpdump -i eth0 -s 34</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">抓取syn报文</span></span><br><span class="line">tcpdump -i any &#x27;tcp[13]&amp;2 !=0&#x27;</span><br><span class="line">tcpdump -i any &#x27;tcp[tcpflags]&amp;tcp-syn !=0&#x27;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">直接读取抓包文件</span></span><br><span class="line">tcpdump -r file.pcap &#x27;tcp[tcpflags] &amp; (tcp-rst) != 0&#x27; </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">就是每 100MB 或者 60 分钟（满足任一条件即可）就生成一个文件，一共 10个文件：</span></span><br><span class="line">tcpdump -i eth0 -w file.pcap -W 10 -C 100 -G 60</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">nc测试udp端口22</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">用 nc 探测 UDP 端口，不通的结果是可信的，而能通（succeeded）的结果并不准确，只能作为参考。</span></span><br><span class="line">nc -v -w 2 47.94.129.219 -u 22</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">ss 查看各种状态的连接个数</span></span><br><span class="line">ss -ant | awk &#x27;&#123;++s[$1]&#125;END&#123;for(k in s) print k,s[k]&#125;&#x27;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">http压力测试，并发请求100次，总共20万请求</span></span><br><span class="line">ab -c 100 -n 200000 http://www.baidu.com/</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">衡量一台主机的网络处理能力，包量,如果增加请求量，包量依旧上不去，就是到瓶颈了</span></span><br><span class="line">sar -n DEV 1 10</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看本地端口范围，客户端连接使用，可能导致源端口不够用</span></span><br><span class="line">sysctl net.ipv4.ip_local_port_range</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">设置TIME_WAIT连接个数为100，超过的会被系统强制关闭。</span></span><br><span class="line">sysctl net.ipv4.tcp_max_tw_buckets=100</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">按照http 事务耗时过滤</span></span><br><span class="line">http.time</span><br></pre></td></tr></table></figure><h3 id="https明文方法"><a href="#https明文方法" class="headerlink" title="https明文方法"></a>https明文方法</h3><ol><li>创建一个用来存放 key 信息的日志文件，然后在系统里配置一个环境变量 <strong>SSLKEYLOGFILE</strong>，它的值就是这个文件的路径.&#x2F;my_ssl.log。</li><li>启动抓包程序，然后访问 HTTPS 站点，此时 TLS 密钥信息将会导出到这个日志文件，而加密报文也会随着抓包，被保存到抓包文件中。</li><li>在 Wireshark 里，打开 编辑-&gt;首选项-&gt;protocols 菜单，在 Protocol 列表里找到 TLS，<strong>然后把 (Pre)-Master-Secret log filename 配置为那个文件的路径my_ssl.log。</strong></li></ol><h3 id="openssl-测试https"><a href="#openssl-测试https" class="headerlink" title="openssl 测试https"></a>openssl 测试https</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">openssl s_client -connect www.baidu.com:443</span><br><span class="line">---</span><br><span class="line">GET / HTTP/1.1                     </span><br><span class="line"></span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Accept-Ranges: bytes</span><br><span class="line">Cache-Control: no-cache</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Content-Length: 9508</span><br><span class="line">Content-Type: text/html</span><br></pre></td></tr></table></figure><h3 id="TCP-Window-Full"><a href="#TCP-Window-Full" class="headerlink" title="TCP Window Full"></a>TCP Window Full</h3><p>TCP Window Full 这个信息非常直接明了，就是说“接收窗口满了”。不过，你可别以为这个信 息是 TCP 报文里的某个字段。其实，它只是 Wireshark 通过分析得出的信息。你有没有注意 到，TCP Window Full 前后是有方括号的。一般来说，Wireshark 自己分析得到的信息，都会 用方括号括起来，而 TCP 报文本身的字段，是不会带这种方括号的。</p><h3 id="获取请求源IP"><a href="#获取请求源IP" class="headerlink" title="获取请求源IP"></a>获取请求源IP</h3><ul><li>应用层： http头部 X-Forwarded-For，依次存放代理的源IP</li><li>传输层 ：TOA 全称是 TCP Option Address，它是利用 TCP Options 的字段来承载真实源 IP 信息，TCP Options 是可变长的，最长为 40 字节（ Option 项由三部分组成： op-kind； op-length； op-data）</li><li>Proxy Protocol：这个方案是 HAProxy（另外一个广泛应用的反向代理软件）工程师提出的。它的实现原理是 这样的：  客户端在 TCP 握手完成之后，在应用层数据发送之前，插入一个包，这个包的 payload 就 是真实源 IP。也就是说，在三次握手后，第四个包不是应用层请求，而是一个包含了真实 源 IP 信息的 TCP 包，这样应用层请求会延后一个包，从第五个包开始。 服务端也需要支持 Proxy Protocol，以此来识别三次握手后的这个额外的数据包，提取出真 实源 IP。</li></ul><h3 id="grpc-明文"><a href="#grpc-明文" class="headerlink" title="grpc 明文"></a>grpc 明文</h3><ul><li>确保wireshark版本3.4及以上，要支持protobuf协议</li><li>配置proto文件 ，编辑-&gt;首选项-&gt;protocols 菜单，在 Protocol 列表里找到 protobuf，上传proto文件并且打开选项</li><li>导入抓包文件到wireshark，输入grpc过滤，选中报文右键decode as-&gt;添加端口和HTTP2后点击save。</li></ul><h3 id="常用的过滤条件"><a href="#常用的过滤条件" class="headerlink" title="常用的过滤条件"></a>常用的过滤条件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">grpc.message_data contains &quot;3_0_103&quot;</span><br><span class="line">tcp contains &quot;abc&quot;</span><br><span class="line">ip contains &quot;abc&quot;</span><br><span class="line">http contains &quot;abc&quot;</span><br><span class="line"></span><br><span class="line">tcp.flags.reset eq 1 #找到RST报文</span><br><span class="line">tcp.flags.syn eq 1 #找到握手的SYN报文</span><br><span class="line">tcp.flags.fin eq 1 #找到挥手的FIN报文</span><br><span class="line"></span><br><span class="line">tcp.payload contains 61-62-63  #tcp中含有abc</span><br><span class="line">frame.time &gt;=&quot;Mar 28, 2022 00:00:00&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">C接口告警</span></span><br><span class="line">tcp.payload[12:2]==f701</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">C接口告警确认</span></span><br><span class="line">tcp.payload[12:2]==f801</span><br></pre></td></tr></table></figure><h3 id="丢包排查"><a href="#丢包排查" class="headerlink" title="丢包排查"></a>丢包排查</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">netstat -s | grep retransmited</span><br><span class="line">6734 segments retransmited</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">如果这个数据一致增长，代表存在丢包</span></span><br><span class="line"></span><br><span class="line">traceroute -I 192.168.4.80</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">* 代表没有响应，可能是设备就不回复ICMP端口不可达报文，带上-I参数。</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">中间路径的丢包率</span></span><br><span class="line">mtr -c 10 -r 8.8.8.8</span><br></pre></td></tr></table></figure><h3 id="keep-alive"><a href="#keep-alive" class="headerlink" title="keep-alive"></a>keep-alive</h3><ul><li>首先，对于 TCP Keep-alive，你需要掌握：默认 TCP 连接并不启用 Keep-alive，若要打开的话要显式地调用 setsockopt()，来设置保活包的发送间隔、等待时间、重试<br>  个数等配置。在全局层面，Linux 还默认有 3 个跟 Keep-alive 相关的内核配置项可以调整：tcp_Keepalive_time，tcp_Keepalive_probes，还有 tcp_Keepalive_intvl。<br>  TCP 心跳包的特点是，它的序列号是上一个包的下个序列号 -1，而心跳回复包的确认号是这个序列号 -1+1（即还是这个序列号）。 </li><li>然后，对于 HTTP Keep-alive 的知识点，你需要理解：HTTP&#x2F;1.0 默认是短连接，HTTP&#x2F;1.1 和 2 默认是长连接。Connection: Keep-alive 在 HTTP&#x2F;1.0 里，能起到维持长<br>  连接的作用，而在 HTTP&#x2F;1.1 里面没有这个作用（因为默认就是长连接）。Connection: Close 在 HTTP&#x2F;1.1 里，可以起到优雅关闭连接的作用。<br>  这个头部在流量调度场景下也很有用，能明显加快基于 DNS&#x2F;GSLB 的流量调整的收敛速度。</li></ul><h3 id="TLS"><a href="#TLS" class="headerlink" title="TLS"></a>TLS</h3><p>TLS 的“四大护法”。 它们的组合，就是密码套件 Cipher Suite。TLS 握手的重要任 务之一，就是找到双方共同支持的那个密码套件。</p><ul><li>密钥交换算法：保证对称密钥的交换是安全的，典型算法包括 DHE、ECDHE。 </li><li>身份验证和签名算法：确认服务端的身份，其实就是对证书的验证，非对称算法就用在这 里。典型算法包括 RSA、ECDSA。 </li><li>对称加密算法：对应用层数据进行加密，典型算法包括 AES、DES。 </li><li>消息完整性校验算法：确保消息不被篡改，典型算法包括 SHA1、SHA256。</li></ul><p>一个典型的密码套件： TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA（0xc013）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Wireshark 的主界面还有个特点，就是当它的 Information 列展示的是应用层信息时，这个报文的 TCP 层面的控制信息就不显示了。&lt;/p&gt;
&lt;p&gt;第一个 FIN 控制报文，并没有像常规的那样单独出现，而是合并（Piggybacking）在 POST 报文里！</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>文件系统</title>
    <link href="https://gitfei1.github.io/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
    <id>https://gitfei1.github.io/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</id>
    <published>2024-02-28T07:51:57.000Z</published>
    <updated>2024-02-28T07:53:11.254Z</updated>
    
    <content type="html"><![CDATA[<h3 id="磁盘格式化"><a href="#磁盘格式化" class="headerlink" title="磁盘格式化"></a>磁盘格式化</h3><p>整理和分配超级快、inode区域、block区域。</p><h4 id="superblock"><a href="#superblock" class="headerlink" title="superblock"></a>superblock</h4><p>存储文件系统描述信息，如inode数量、inode大小、block数量、block大小、挂载信息等</p><h4 id="block"><a href="#block" class="headerlink" title="block"></a>block</h4><p>block是实际存储文件数据的地方。</p><p>ext2文件系统的block限制</p><p><img src="/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/1709089160389-cdc24321-a77d-41a0-b5f2-82b944a85b63.png" alt="img"></p><ul><li>一个block最多只能存放一个文件</li><li>格式化之后block大小和数量不再变化</li><li>如果文件太大，会占用多个block</li></ul><p>对于小文件，由于占不满block会导致空间的浪费；对于大文件，由于占用多个block会导致磁盘读写效率降低。</p><h4 id="inode"><a href="#inode" class="headerlink" title="inode"></a>inode</h4><p>inode是存储文件元数据的地方</p><p><img src="/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/1709089662542-b80e5e3b-6791-4226-96e0-5338b2e7ba34.png" alt="img"></p><ul><li>每个文件占用一个inode，文件系统文件数量与inode数量有关</li><li>inode数量和大小在磁盘格式化时已确定下来</li><li>系统读取文件，先找到inode确定访问权限，然后找到block读取。</li></ul><h4 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h4><ul><li>目录的inode记录了目录的访问权限以及目录的block编号。</li><li>目录block存储了该目录下所有的 文件名:文件inode号信息。</li></ul><h4 id="目录树读取"><a href="#目录树读取" class="headerlink" title="目录树读取"></a>目录树读取</h4><ul><li>读取一个文件，要从根目录一层一层往下读</li></ul><p>举例 &#x2F;etc&#x2F;passwd文件读取过程</p><ul><li>根据挂载点信息获取&#x2F; 的inode，判断权限允许访问后，找到inode指向的block，从block查找&#x2F;etc这个目录的inode信息。</li><li>查询&#x2F;etc的inode后，允许访问，找到指向的block，获取&#x2F;etc&#x2F;passwd文件的inode信息。</li><li>inode信息允许访问后，找到block，然后读取数据。</li></ul><h4 id="inode-bitmap和block-bitmap"><a href="#inode-bitmap和block-bitmap" class="headerlink" title="inode bitmap和block bitmap"></a>inode bitmap和block bitmap</h4><p>新创建文件的流程：</p><ul><li>先确定使用者对于欲新增文件的目录是否具有w和x权限，有的话才能新增。</li><li>根据inode bitmap找到没有使用的inode号，将文件的权限写入</li><li>根据block bitmap找到没有使用的block号，将文件实际数据写入，且更新inode中block的指向。</li><li>将inode和block更新到inode bitmap和block bitmap</li></ul><h3 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h3><p>文件系统是操作系统提供的，用于访问磁盘设备的软件。</p><p>同一个文件系统中的某个inode号只会对应到一个文件内容，可以通过判断inode号确认不同文件名是否为相同的文件。</p><h4 id="硬链接"><a href="#硬链接" class="headerlink" title="硬链接"></a>硬链接</h4><ul><li>两个文件名不同的文件指向同一个inode，获取到的block自然也相同，文件内容自然也相同。</li><li>如下： inode号都是1735156</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@w2 test]# touch a </span><br><span class="line">[root@w2 test]# ll -i</span><br><span class="line">1735156 -rw-r--r--. 1 root root 0 2月  28 22:36 a</span><br><span class="line">[root@w2 test]# ln a a.test</span><br><span class="line">[root@w2 test]# ll -i</span><br><span class="line">1735156 -rw-r--r--. 2 root root 0 2月  28 22:36 a</span><br><span class="line">1735156 -rw-r--r--. 2 root root 0 2月  28 22:36 a.test</span><br></pre></td></tr></table></figure><h4 id="软连接"><a href="#软连接" class="headerlink" title="软连接"></a>软连接</h4><ul><li>属于完成不同的文件，inode号不相同，block存储了源文件的路径，但是文件内容是相同的。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@w2 test]# touch b</span><br><span class="line">[root@w2 test]# echo xxx &gt;b</span><br><span class="line">[root@w2 test]# ln -s b b.test</span><br><span class="line">[root@w2 test]# cat b.test</span><br><span class="line">xxx</span><br><span class="line">[root@w2 test]# ll -i</span><br><span class="line">总用量 4</span><br><span class="line">1735156 -rw-r--r--. 1 root root 4 2月  28 22:39 b</span><br><span class="line">1735157 lrwxrwxrwx. 1 root root 1 2月  28 22:40 b.test -&gt; b</span><br></pre></td></tr></table></figure><h3 id="虚拟文件系统"><a href="#虚拟文件系统" class="headerlink" title="虚拟文件系统"></a>虚拟文件系统</h3><p><img src="/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/1709103312894-bd6e4473-ff94-4e8e-9022-adf9863fd783.png" alt="img"></p><h3 id="内存与磁盘"><a href="#内存与磁盘" class="headerlink" title="内存与磁盘"></a>内存与磁盘</h3><ul><li>内存要比磁盘快很多，一般将常用的文件数据放到内存缓存，以加快访问速度。</li><li>内存加载文件后更新了会标记为dirty，系统会定时将dirty的数据刷新到磁盘</li><li>正常关机时，会主动调用sync指令将数据加载到磁盘。</li></ul><h3 id="挂载"><a href="#挂载" class="headerlink" title="挂载"></a>挂载</h3><ul><li>将文件系统与目录树结合的动作称为挂载。</li><li>挂载点必须是目录树，是文件系统的入口</li><li>挂载之后就可以对文件系统进行访问了</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;磁盘格式化&quot;&gt;&lt;a href=&quot;#磁盘格式化&quot; class=&quot;headerlink&quot; title=&quot;磁盘格式化&quot;&gt;&lt;/a&gt;磁盘格式化&lt;/h3&gt;&lt;p&gt;整理和分配超级快、inode区域、block区域。&lt;/p&gt;
&lt;h4 id=&quot;superblock&quot;&gt;&lt;a href=</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>博客搭建</title>
    <link href="https://gitfei1.github.io/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    <id>https://gitfei1.github.io/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</id>
    <published>2024-02-27T03:37:22.000Z</published>
    <updated>2024-02-27T06:43:38.109Z</updated>
    
    <content type="html"><![CDATA[<p>博客搭建以及使用参考连接：<a href="https://xie.infoq.cn/article/90dc08c57463df3a1b2ad960f">https://xie.infoq.cn/article/90dc08c57463df3a1b2ad960f</a></p><p>还有一个要注意的点是，在绑定github page的时候，创建的仓库必须是github的用户名。</p><p>记得要更换源！！！！</p><p>这是因为网络问题（npm 的服务器位于国外下载慢），可以使用 cnpm（淘宝团队做的国内镜像）的获取镜像或者直接修改 npm 的资源获取地址为国内的。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装cnmp</span></span><br><span class="line"></span><br><span class="line">npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">直接修改npm资源获取地址（推荐）</span></span><br><span class="line"></span><br><span class="line">npm config set registry http://registry.npm.taobao.org</span><br></pre></td></tr></table></figure><p>发布文章流程</p><ul><li>hexo new 文章名</li><li>hexo clean</li><li>hexo g</li><li>将md放过去·blog\source_posts然后执行 hexo d</li></ul><p><strong>图片插件</strong></p><p><strong>typora写好的文档，本地能显示图片，部署后显示不了图片。</strong></p><p>解决：插件hexo-renderer-marked解决了这个问题。可以只用npm install hexo-renderer-marked命令直接安装，之后在config.yaml中更改配置如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">post_asset_folder:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">marked:</span></span><br><span class="line">  <span class="attr">prependRoot:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">postAsset:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>在使用hexo new xxx 之后，会生成xxx文件夹和xxx.md，只需要把图片a.jpg放入文件夹，</p><p>之后就可以使用<code>![](a.jpg)</code>的方式愉快的插入图片了。</p><h3 id="提交谷歌收录"><a href="#提交谷歌收录" class="headerlink" title="提交谷歌收录"></a>提交谷歌收录</h3><ol><li>验证站点</li></ol><p>选择html添加代码验证方式，将代码添加到public目录下的index.html文件中，位置是head部分的title附近即可。然后重新部署 hexo d(不要hexo clean会覆盖)</p><ol><li>添加站点地图</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-sitemap --save</span><br></pre></td></tr></table></figure><p>配置Hexo的_config.yml文件，添加如下字段:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">sitemap:</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">sitemap.xml</span></span><br></pre></td></tr></table></figure><p>执行hexo clean、hexo g之后，修改_config.yaml中url字段为博客网站的地址。然后hexo d 部署。</p><p>最后在站点地图添加即可。</p><p><img src="/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/%E7%AB%99%E9%95%BF%E5%9C%B0%E5%9B%BE.png" alt="img"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;博客搭建以及使用参考连接：&lt;a href=&quot;https://xie.infoq.cn/article/90dc08c57463df3a1b2ad960f&quot;&gt;https://xie.infoq.cn/article/90dc08c57463df3a1b2ad960f&lt;/a&gt;&lt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>链路追踪</title>
    <link href="https://gitfei1.github.io/%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA/"/>
    <id>https://gitfei1.github.io/%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA/</id>
    <published>2024-02-27T03:34:49.000Z</published>
    <updated>2024-02-27T03:47:29.254Z</updated>
    
    <content type="html"><![CDATA[<h3 id="opentracing"><a href="#opentracing" class="headerlink" title="opentracing"></a>opentracing</h3><h3 id="trace和span"><a href="#trace和span" class="headerlink" title="trace和span"></a>trace和span</h3><ul><li>Span，理解为一次方法调用, 一个程序块的调用, 或者一次RPC&#x2F;数据库访问.只要是一个具有完整时间周期的程序访问，都可以被认为是一个span.</li><li>链路追踪中的一个进程使用一个 trace 实例标识，每个服务或函数使用一个 span 标识</li><li>一次http请求事务是一个trace，有一个trace标识。</li></ul><p><img src="/%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA/span%E5%85%B3%E7%B3%BB%E5%9B%BE.png" alt="img"></p><h3 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h3><ul><li><p>创建一个新Span</p></li><li><p>将SpanContext上下文Inject（注入）到carrier</p></li><li><p>将SpanContext上下文从carrier中Extract（提取）</p></li><li><p>获取Span的SpanContext</p></li><li><p>结束Span</p></li><li><p>为Span设置tag</p></li></ul><h3 id="jaeger"><a href="#jaeger" class="headerlink" title="jaeger"></a>jaeger</h3><p>Jaeger 是 Uber 开发的一款调用链服务端产品，开发语言为 golang ，能够兼容接收 OpenTracing 格式的数据。根据其发展历史，可以说是 Zipkin 的升级版。另外，其基于 udp （也可以 http ）的传输协议，更加定位了其高效、迅速的特点。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">docker安装</span></span><br><span class="line">docker run -d -p 5775:5775/udp -p 16686:16686 -p 14250:14250 -p 14268:14268 jaegertracing/all-in-one:latest</span><br></pre></td></tr></table></figure><p>在16686监听，访问前端UI页面 <a href="http://xxx:16686/search">http://xxx:16686/search</a></p><p>Jaeger主要由以下几部分组成：</p><ol><li>Jaeger Client： 为了不同语言实现了符合OpenTracing标准的SDK。应用程序通过API写入数据， client library把trace信息按照应用程序制定的采样策略传递给jaeger-agent。</li><li>Agent： 他是一个监听在UDP端口上接收span数据的网络守护进程，它会将数据批量发送给collector。他被设计成一个基础组件，部署到所有的宿主机上。Agent将client library和collector解耦，为client library屏蔽了路由和发现collector的细节。</li><li>Collector：接收jaeger-agent发送来的数据，然后将数据写入后端存储。Collector被设计成无状态的组件，因此用户可以运行任意数量的Collector。</li><li>Data Store：后端存储被设计成一个可插拔的组件，支持数据写入cassandra， elastic search。</li><li>Query：接收查询请求，然后从后端存储系统中检索tarce并通过UI进行展示。Query是无状态的，可以启动多个实例。把他们部署在nginx这样的负载均衡器后面。</li></ol><p><img src="/%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA/jaeger%E5%9F%BA%E6%9C%AC%E7%BB%84%E4%BB%B6.png" alt="img"></p><h3 id="HTTP-跨进程追踪"><a href="#HTTP-跨进程追踪" class="headerlink" title="HTTP 跨进程追踪"></a>HTTP 跨进程追踪</h3><p>inject 函数打包上下文到 Header 中，而 extract 函数则将其解析出来。</p><p><img src="/%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA/%E8%B7%A8%E8%BF%9B%E7%A8%8B%E8%BF%BD%E8%B8%AA.png" alt="img"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">tracer, closer, _ := CreateTracer(<span class="string">&quot;UserinfoService&quot;</span>)</span><br><span class="line"><span class="comment">// 创建第一个 span A</span></span><br><span class="line">parentSpan := tracer.StartSpan(<span class="string">&quot;A&quot;</span>)</span><br><span class="line"><span class="comment">// 调用其它服务</span></span><br><span class="line">GetUserInfo(tracer, parentSpan)</span><br><span class="line"><span class="comment">// 结束 A</span></span><br><span class="line">parentSpan.Finish()</span><br><span class="line"><span class="comment">// 结束当前 tracer</span></span><br><span class="line">closer.Close()</span><br><span class="line"></span><br><span class="line">reader := bufio.NewReader(os.Stdin)</span><br><span class="line">_, _ = reader.ReadByte()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CreateTracer</span><span class="params">(servieName <span class="type">string</span>)</span></span> (opentracing.Tracer, io.Closer, <span class="type">error</span>) &#123;</span><br><span class="line"><span class="keyword">var</span> cfg = jaegercfg.Configuration&#123;</span><br><span class="line">ServiceName: servieName,</span><br><span class="line">Sampler: &amp;jaegercfg.SamplerConfig&#123;</span><br><span class="line">Type:  jaeger.SamplerTypeConst,</span><br><span class="line">Param: <span class="number">1</span>,</span><br><span class="line">&#125;,</span><br><span class="line">Reporter: &amp;jaegercfg.ReporterConfig&#123;</span><br><span class="line">LogSpans: <span class="literal">true</span>,</span><br><span class="line"><span class="comment">// 按实际情况替换你的 ip</span></span><br><span class="line">CollectorEndpoint: <span class="string">&quot;http://xxx:14268/api/traces&quot;</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">jLogger := jaegerlog.StdLogger</span><br><span class="line">tracer, closer, err := cfg.NewTracer(</span><br><span class="line">jaegercfg.Logger(jLogger),</span><br><span class="line">)</span><br><span class="line"><span class="keyword">return</span> tracer, closer, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 请求远程服务，获得用户信息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetUserInfo</span><span class="params">(tracer opentracing.Tracer, parentSpan opentracing.Span)</span></span> &#123;</span><br><span class="line"><span class="comment">// 继承上下文关系，创建子 span</span></span><br><span class="line">childSpan := tracer.StartSpan(</span><br><span class="line"><span class="string">&quot;B&quot;</span>,</span><br><span class="line">opentracing.ChildOf(parentSpan.Context()),</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">url := <span class="string">&quot;http://127.0.0.1:8081/Get&quot;</span></span><br><span class="line">req, _ := http.NewRequest(<span class="string">&quot;GET&quot;</span>, url, <span class="literal">nil</span>)</span><br><span class="line"><span class="comment">// 设置 tag</span></span><br><span class="line">ext.SpanKindRPCClient.Set(childSpan)</span><br><span class="line">ext.HTTPUrl.Set(childSpan, url)</span><br><span class="line">ext.HTTPMethod.Set(childSpan, <span class="string">&quot;GET&quot;</span>)</span><br><span class="line">tracer.Inject(childSpan.Context(), opentracing.HTTPHeaders, opentracing.HTTPHeadersCarrier(req.Header))</span><br><span class="line">resp, _ := http.DefaultClient.Do(req)</span><br><span class="line">_ = resp <span class="comment">// 丢掉</span></span><br><span class="line"><span class="keyword">defer</span> childSpan.Finish()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">r := gin.Default()</span><br><span class="line"><span class="comment">// 插入中间件处理</span></span><br><span class="line">r.Use(UseOpenTracing())</span><br><span class="line">r.GET(<span class="string">&quot;/Get&quot;</span>, GetUserInfo)</span><br><span class="line">r.Run(<span class="string">&quot;0.0.0.0:8081&quot;</span>) <span class="comment">// listen and serve on 0.0.0.0:8080 (for windows &quot;localhost:8080&quot;)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetUserInfo</span><span class="params">(ctx *gin.Context)</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;收到请求&quot;</span>)</span><br><span class="line">ctx.String(http.StatusOK, <span class="string">&quot;X&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CreateTracer</span><span class="params">(serviceName <span class="type">string</span>, header http.Header)</span></span> (opentracing.Tracer, opentracing.SpanContext, io.Closer, <span class="type">error</span>) &#123;</span><br><span class="line"><span class="keyword">var</span> cfg = jaegercfg.Configuration&#123;</span><br><span class="line">ServiceName: serviceName,</span><br><span class="line">Sampler: &amp;jaegercfg.SamplerConfig&#123;</span><br><span class="line">Type:  jaeger.SamplerTypeConst,</span><br><span class="line">Param: <span class="number">1</span>,</span><br><span class="line">&#125;,</span><br><span class="line">Reporter: &amp;jaegercfg.ReporterConfig&#123;</span><br><span class="line">LogSpans: <span class="literal">true</span>,</span><br><span class="line"><span class="comment">// 按实际情况替换你的 ip</span></span><br><span class="line">CollectorEndpoint: <span class="string">&quot;http://xxx:14268/api/traces&quot;</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">jLogger := jaegerlog.StdLogger</span><br><span class="line">tracer, closer, err := cfg.NewTracer(</span><br><span class="line">jaegercfg.Logger(jLogger),</span><br><span class="line">)</span><br><span class="line"><span class="comment">// 继承别的进程传递过来的上下文</span></span><br><span class="line">spanContext, _ := tracer.Extract(opentracing.HTTPHeaders,</span><br><span class="line">opentracing.HTTPHeadersCarrier(header))</span><br><span class="line"><span class="keyword">return</span> tracer, spanContext, closer, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">UseOpenTracing</span><span class="params">()</span></span> gin.HandlerFunc &#123;</span><br><span class="line">handler := <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line"><span class="comment">// 使用 opentracing.GlobalTracer() 获取全局 Tracer</span></span><br><span class="line">tracer, spanContext, closer, _ := CreateTracer(<span class="string">&quot;userInfoWebService&quot;</span>, c.Request.Header)</span><br><span class="line"><span class="keyword">defer</span> closer.Close()</span><br><span class="line"><span class="comment">// 生成依赖关系，并新建一个 span、</span></span><br><span class="line"><span class="comment">// 这里很重要，因为生成了  References []SpanReference 依赖关系</span></span><br><span class="line">startSpan := tracer.StartSpan(c.Request.URL.Path, ext.RPCServerOption(spanContext))</span><br><span class="line"><span class="keyword">defer</span> startSpan.Finish()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 记录 tag</span></span><br><span class="line"><span class="comment">// 记录请求 Url</span></span><br><span class="line">ext.HTTPUrl.Set(startSpan, c.Request.URL.Path)</span><br><span class="line"><span class="comment">// Http Method</span></span><br><span class="line">ext.HTTPMethod.Set(startSpan, c.Request.Method)</span><br><span class="line"><span class="comment">// 记录组件名称</span></span><br><span class="line">ext.Component.Set(startSpan, <span class="string">&quot;Gin-Http&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 header 中加上当前进程的上下文信息</span></span><br><span class="line">c.Request = c.Request.WithContext(opentracing.ContextWithSpan(c.Request.Context(), startSpan))</span><br><span class="line"><span class="comment">// 传递给下一个中间件</span></span><br><span class="line">c.Next()</span><br><span class="line"><span class="comment">// 继续设置 tag</span></span><br><span class="line">ext.HTTPStatusCode.Set(startSpan, <span class="type">uint16</span>(c.Writer.Status()))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> handler</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用链</p><p><img src="/%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA/%E8%B0%83%E7%94%A8%E9%93%BE.png" alt="img"></p><p>Tag信息</p><p><img src="/%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA/tag%E8%AF%A6%E7%BB%86%E4%BF%A1%E6%81%AF.png" alt="img"></p><p>参考连接 <a href="https://www.cnblogs.com/whuanle/p/14598049.html">https://www.cnblogs.com/whuanle/p/14598049.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;opentracing&quot;&gt;&lt;a href=&quot;#opentracing&quot; class=&quot;headerlink&quot; title=&quot;opentracing&quot;&gt;&lt;/a&gt;opentracing&lt;/h3&gt;&lt;h3 id=&quot;trace和span&quot;&gt;&lt;a href=&quot;#trace和s</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>零拷贝</title>
    <link href="https://gitfei1.github.io/%E9%9B%B6%E6%8B%B7%E8%B4%9D/"/>
    <id>https://gitfei1.github.io/%E9%9B%B6%E6%8B%B7%E8%B4%9D/</id>
    <published>2024-02-22T05:37:33.000Z</published>
    <updated>2024-02-22T06:12:33.201Z</updated>
    
    <content type="html"><![CDATA[<p> 为了传输 320MB 的文件，在用户缓冲区分配了 32KB 的内 存，把文件分成 1 万份传送，然而，这 32KB 是怎么来的？  </p><p> 如果用户缓冲区过 大，它就无法一次性把消息全拷贝给 socket 缓冲区；如果用户缓冲区过小，则会导致过多 的 read&#x2F;write 系统调用。  </p><p>pagecache:磁盘高速缓存</p><ul><li>在内存中取一小块空间用于存放经常访问的磁盘的数据，局部性原理。</li><li>预读技术，会读取多一些数据，提高顺序访问的性能</li></ul><p> 用 PageCache 缓存最近访问的数据，当空间不足时淘汰最久 未被访问的缓存（即 LRU 算法）。读磁盘时优先到 PageCache 中找一找，如果数据存在 便直接返回，这便大大提升了读磁盘的性能。  </p><p>普通磁盘文件<strong>读取并通过socket发送</strong>出去需要经过<strong>4次内存拷贝和4次用户态与内核态切换。</strong></p><p><img src="/%E9%9B%B6%E6%8B%B7%E8%B4%9D/%E6%97%A0%E9%9B%B6%E6%8B%B7%E8%B4%9D.png" alt="img"></p><p>零拷贝–sendfile方法</p><p>操作系统内核提供的函数实现了该功能，<strong>因为不经过用户缓冲区，要求用户不需要对磁盘读取的内容做处理。</strong></p><p>数据处理不经过用户缓冲区，减少了<strong>两次用户态到内核态的上下文切换，减少了一次内存拷贝。</strong></p><p><img src="/%E9%9B%B6%E6%8B%B7%E8%B4%9D/sendfile%E9%9B%B6%E6%8B%B7%E8%B4%9D.png" alt="img"></p><p>DMA技术下的零拷贝技术 Direct Memory Access</p><p><a href="https://www.baike.com/wikiid/3618426234596855008?from=wiki_content&prd=innerlink">DMA</a>是指外部设备不通过CPU而直接与系统内存交换数据的接口技术，再减少一次内存拷贝。</p><p><img src="/%E9%9B%B6%E6%8B%B7%E8%B4%9D/DMA%E4%B8%8E%E9%9B%B6%E6%8B%B7%E8%B4%9D.png" alt="img"></p><p>异步io</p><p>发起异步io请求后，立即返回处理其他任务，待有数据后会通知用户，然后进行数据读取。</p><p><img src="/%E9%9B%B6%E6%8B%B7%E8%B4%9D/%E5%BC%82%E6%AD%A5IO.png" alt="img"></p><p>直接io</p><ul><li>不经过pagecache的称为直接io,经过pagecache的称为缓存io。</li><li>对于磁盘，异步io仅支持直接io.</li></ul><p> 大文 件不应使用 PageCache，进而也不应使用零拷贝技术处理。</p><p>不过，零拷贝有一个缺点，就是不允许进程对文件内容作一些加工再发送，比如数据压缩后再发送。另外，当 PageCache 引发负作用时，也不能使用零拷贝，此时可以用异步 IO+直接 IO 替换。我们通常会设定一个文件大小阈值，针对大文件使用异步 IO 和直接 IO，而对小文件使用零拷贝。</p><p>大文件采用异步io+直接io的方式，不走pageCache。</p><p>小文件采用pagecache方式</p><p> 由于文件太大，文件中某一部分内容被再次访问到的概率其实非常低。这带来了 2 个问题：首先，由于 PageCache 长期被大文件占据，热点小文件就无法充分使用 PageCache，它们读起来变慢了；其次，PageCache 中的大文件没有享受到缓存的好处， 但却耗费 CPU 多拷贝到 PageCache 一次？</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt; 为了传输 320MB 的文件，在用户缓冲区分配了 32KB 的内 存，把文件分成 1 万份传送，然而，这 32KB 是怎么来的？  &lt;/p&gt;
&lt;p&gt; 如果用户缓冲区过 大，它就无法一次性把消息全拷贝给 socket 缓冲区；如果用户缓冲区过小，则会导致过多 的 read&amp;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>epoll笔记</title>
    <link href="https://gitfei1.github.io/epoll%E7%AC%94%E8%AE%B0/"/>
    <id>https://gitfei1.github.io/epoll%E7%AC%94%E8%AE%B0/</id>
    <published>2024-02-22T05:23:51.000Z</published>
    <updated>2024-02-27T04:01:23.276Z</updated>
    
    <content type="html"><![CDATA[<p>C10M 千万级连接、高性能、高并发</p><p>水平触发是只要读缓冲区有数据，就会一直触发可读信号，而边缘触发仅仅在空变为非空的时候通知一次</p><h3 id="网络事件"><a href="#网络事件" class="headerlink" title="网络事件"></a>网络事件</h3><p>处理基于 TCP 的应用层协议时，一个请求的处理代码必须被 拆分到多个回调函数中，由异步框架在相应的事件生成时调用它们。这就是事件驱动方式， 它通过减少上下文切换次数，实现了 C10M 级别的高并发。  </p><p> 读事件与写事件，其中，读事件表示有到 达的消息需要处理，而写事件表示可以发送消息（TCP 连接的写缓冲区中有可用空间）  </p><p> 多个请求复 用了一个进程，也叫做多路复用（或者叫做时分多路复用）。我们熟知的 epoll，就是内核 提供给用户态的多路复用接口，进程可以通过它从内核中获取事件。  </p><p> 当调用 write 函 数发送时，会先把内存中的数据拷贝到写缓冲区中后，再发送到网卡上。为何要多此一举呢？这是因为在对方没有明确表示收到前，TCP 会通过<strong>定时器重发写缓冲区中的数据</strong>，保证消息能够到达对方。  </p><p>tcp 与事件之间的关系</p><ul><li>在连接建立时，客户端会生成写事件write，服务端会生成读事件 accept</li><li>数据交互过程中，接受数据产生读事件，发送数据与内核缓冲区有关，有空闲缓冲区时，产生 写事件。</li><li>连接关闭时，被动关闭方会收到读事件，提醒执行close方法</li></ul><p><img src="/epoll%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6.png" alt="img"></p><p><img src="/epoll%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E4%BA%A4%E4%BA%92%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6.png" alt="img"></p><p><img src="/epoll%E7%AC%94%E8%AE%B0/%E5%85%B3%E9%97%AD%E8%BF%9E%E6%8E%A5%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6.png" alt="img"></p><p>事件回调函数处理时间要足够短。</p><ul><li>计算任务：要么把这 样的请求放在独立的线程中完成，要么把请求的处理过程拆分成多段，确保每段能够快速执 行完，同时每段执行完都要均等地处理其他事件，  </li><li>磁盘读写：写很快，write直接放到pagecache就算完成；读取大文件，分成多个小文件间隔读取。</li><li>网络请求：设置socket为非阻塞式。</li></ul><p>epoll</p><ul><li>将要监听事件的socket注册到内核。</li><li>收集事件，不用重复传递socket，节省上下文切换内存拷贝消耗。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;C10M 千万级连接、高性能、高并发&lt;/p&gt;
&lt;p&gt;水平触发是只要读缓冲区有数据，就会一直触发可读信号，而边缘触发仅仅在空变为非空的时候通知一次&lt;/p&gt;
&lt;h3 id=&quot;网络事件&quot;&gt;&lt;a href=&quot;#网络事件&quot; class=&quot;headerlink&quot; title=&quot;网络事件</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>cdn</title>
    <link href="https://gitfei1.github.io/cdn/"/>
    <id>https://gitfei1.github.io/cdn/</id>
    <published>2024-02-22T05:22:50.000Z</published>
    <updated>2024-02-22T05:23:04.393Z</updated>
    
    <content type="html"><![CDATA[<p>内容分发网络（CDN）通过在多个地理位置建立一个入网点（PoP）或一组 CDN 边缘服务器来工作。这个分布在不同地理位置的网络<strong>基于缓存、动态加速和边缘逻辑计算</strong>的原则工作。</p><h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p><a href="https://aws.amazon.com/caching/cdn/">CDN 中的缓存</a>的工作原理如下：</p><ol><li>来自偏远地理位置的网站访客首次从您的网站请求静态 Web 内容。</li><li>请求到达您的 Web 应用程序服务器或原始服务器。原始服务器将响应发送给远程访客。同时，它还将响应的副本发送到与该访客地理上最近的 CDN POP。</li><li>CDN POP 服务器将副本存储为缓存文件。</li><li>下次该访客或该位置的任何其他访客发出相同的请求时，将由缓存服务器而不是原始服务器发送响应。</li></ol><h3 id="动态加速"><a href="#动态加速" class="headerlink" title="动态加速"></a>动态加速</h3><p>动态加速是指通过在 Web 应用程序和客户端之间设置中间 CDN 服务器，从而加快对动态 Web 内容请求的服务器响应。缓存不适用于动态 Web 内容，因为内容因用户请求而异。CDN 服务器必须针对每个动态请求重新连接原始服务器，但它们通过优化自己与原始服务器之间的连接加速了该过程。<strong>可能还需要花费时间打开和关闭连接以进行安全验证。另一方面，如果附近的 CDN 服务器将请求转发到原始服务器，它们就已经建立了一个持续的、受信任的连接。</strong></p><ul><li>智能路由算法</li><li>地理位置靠近原始服务器</li><li>能够处理客户端请求，缩减其大小</li></ul><h3 id="边缘逻辑计算"><a href="#边缘逻辑计算" class="headerlink" title="边缘逻辑计算"></a>边缘逻辑计算</h3><p>您可以对 CDN 边缘服务器进行编程，以执行简化客户端和服务器之间通信的逻辑计算。例如，此服务器可以执行以下操作：</p><ul><li>检查用户请求并修改缓存行为。</li><li>验证和处理不正确的用户请求。</li><li>在响应之前修改或优化内容。</li></ul><p>Web 服务器和网络边缘之间的应用程序逻辑分布有助于开发人员减轻原始服务器的计算需求并提高网站性能。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;内容分发网络（CDN）通过在多个地理位置建立一个入网点（PoP）或一组 CDN 边缘服务器来工作。这个分布在不同地理位置的网络&lt;strong&gt;基于缓存、动态加速和边缘逻辑计算&lt;/strong&gt;的原则工作。&lt;/p&gt;
&lt;h3 id=&quot;缓存&quot;&gt;&lt;a href=&quot;#缓存&quot; clas</summary>
      
    
    
    
    
  </entry>
  
</feed>
