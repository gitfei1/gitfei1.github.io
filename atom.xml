<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>不知道的博客</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2024-02-27T03:42:37.890Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>不知道</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>博客搭建</title>
    <link href="http://example.com/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    <id>http://example.com/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</id>
    <published>2024-02-27T03:37:22.000Z</published>
    <updated>2024-02-27T03:42:37.890Z</updated>
    
    <content type="html"><![CDATA[<p>博客搭建以及使用参考连接：<a href="https://xie.infoq.cn/article/90dc08c57463df3a1b2ad960f%EF%BC%8C%E9%9D%9E%E5%B8%B8%E6%9C%89%E6%95%88%EF%BC%8C%E4%B8%80%E6%AC%A1%E6%88%90%E5%8A%9F">https://xie.infoq.cn/article/90dc08c57463df3a1b2ad960f，非常有效，一次成功</a></p><p>还有一个要注意的点是，在绑定github page的时候，创建的仓库必须是github的用户名。</p><p>记得要更换源！！！！</p><p>这是因为网络问题（npm 的服务器位于国外下载慢），可以使用 cnpm（淘宝团队做的国内镜像）的获取镜像或者直接修改 npm 的资源获取地址为国内的。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装cnmp</span></span><br><span class="line"></span><br><span class="line">npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">直接修改npm资源获取地址（推荐）</span></span><br><span class="line"></span><br><span class="line">npm config set registry http://registry.npm.taobao.org</span><br></pre></td></tr></table></figure><p>发布文章流程</p><ul><li>hexo new 文章名</li><li>hexo clean</li><li>hexo g</li><li>将md放过去·blog\source_posts然后执行 hexo d</li></ul><p><strong>图片插件</strong></p><p><strong>typora写好的文档，本地能显示图片，部署后显示不了图片。</strong></p><p>解决：插件hexo-renderer-marked解决了这个问题。可以只用npm install hexo-renderer-marked命令直接安装，之后在config.yaml中更改配置如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">post_asset_folder:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">marked:</span></span><br><span class="line">  <span class="attr">prependRoot:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">postAsset:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>在使用hexo new xxx 之后，会生成xxx文件夹和xxx.md，只需要把图片a.jpg放入文件夹，</p><p>之后就可以使用<code>![](a.jpg)</code>的方式愉快的插入图片了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;博客搭建以及使用参考连接：&lt;a href=&quot;https://xie.infoq.cn/article/90dc08c57463df3a1b2ad960f%EF%BC%8C%E9%9D%9E%E5%B8%B8%E6%9C%89%E6%95%88%EF%BC%8C%E4%B8%</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>链路追踪</title>
    <link href="http://example.com/%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA/"/>
    <id>http://example.com/%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA/</id>
    <published>2024-02-27T03:34:49.000Z</published>
    <updated>2024-02-27T03:47:29.254Z</updated>
    
    <content type="html"><![CDATA[<h3 id="opentracing"><a href="#opentracing" class="headerlink" title="opentracing"></a>opentracing</h3><h3 id="trace和span"><a href="#trace和span" class="headerlink" title="trace和span"></a>trace和span</h3><ul><li>Span，理解为一次方法调用, 一个程序块的调用, 或者一次RPC&#x2F;数据库访问.只要是一个具有完整时间周期的程序访问，都可以被认为是一个span.</li><li>链路追踪中的一个进程使用一个 trace 实例标识，每个服务或函数使用一个 span 标识</li><li>一次http请求事务是一个trace，有一个trace标识。</li></ul><p><img src="/%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA/span%E5%85%B3%E7%B3%BB%E5%9B%BE.png" alt="img"></p><h3 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h3><ul><li><p>创建一个新Span</p></li><li><p>将SpanContext上下文Inject（注入）到carrier</p></li><li><p>将SpanContext上下文从carrier中Extract（提取）</p></li><li><p>获取Span的SpanContext</p></li><li><p>结束Span</p></li><li><p>为Span设置tag</p></li></ul><h3 id="jaeger"><a href="#jaeger" class="headerlink" title="jaeger"></a>jaeger</h3><p>Jaeger 是 Uber 开发的一款调用链服务端产品，开发语言为 golang ，能够兼容接收 OpenTracing 格式的数据。根据其发展历史，可以说是 Zipkin 的升级版。另外，其基于 udp （也可以 http ）的传输协议，更加定位了其高效、迅速的特点。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">docker安装</span></span><br><span class="line">docker run -d -p 5775:5775/udp -p 16686:16686 -p 14250:14250 -p 14268:14268 jaegertracing/all-in-one:latest</span><br></pre></td></tr></table></figure><p>在16686监听，访问前端UI页面 <a href="http://xxx:16686/search">http://xxx:16686/search</a></p><p>Jaeger主要由以下几部分组成：</p><ol><li>Jaeger Client： 为了不同语言实现了符合OpenTracing标准的SDK。应用程序通过API写入数据， client library把trace信息按照应用程序制定的采样策略传递给jaeger-agent。</li><li>Agent： 他是一个监听在UDP端口上接收span数据的网络守护进程，它会将数据批量发送给collector。他被设计成一个基础组件，部署到所有的宿主机上。Agent将client library和collector解耦，为client library屏蔽了路由和发现collector的细节。</li><li>Collector：接收jaeger-agent发送来的数据，然后将数据写入后端存储。Collector被设计成无状态的组件，因此用户可以运行任意数量的Collector。</li><li>Data Store：后端存储被设计成一个可插拔的组件，支持数据写入cassandra， elastic search。</li><li>Query：接收查询请求，然后从后端存储系统中检索tarce并通过UI进行展示。Query是无状态的，可以启动多个实例。把他们部署在nginx这样的负载均衡器后面。</li></ol><p><img src="/%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA/jaeger%E5%9F%BA%E6%9C%AC%E7%BB%84%E4%BB%B6.png" alt="img"></p><h3 id="HTTP-跨进程追踪"><a href="#HTTP-跨进程追踪" class="headerlink" title="HTTP 跨进程追踪"></a>HTTP 跨进程追踪</h3><p>inject 函数打包上下文到 Header 中，而 extract 函数则将其解析出来。</p><p><img src="/%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA/%E8%B7%A8%E8%BF%9B%E7%A8%8B%E8%BF%BD%E8%B8%AA.png" alt="img"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">tracer, closer, _ := CreateTracer(<span class="string">&quot;UserinfoService&quot;</span>)</span><br><span class="line"><span class="comment">// 创建第一个 span A</span></span><br><span class="line">parentSpan := tracer.StartSpan(<span class="string">&quot;A&quot;</span>)</span><br><span class="line"><span class="comment">// 调用其它服务</span></span><br><span class="line">GetUserInfo(tracer, parentSpan)</span><br><span class="line"><span class="comment">// 结束 A</span></span><br><span class="line">parentSpan.Finish()</span><br><span class="line"><span class="comment">// 结束当前 tracer</span></span><br><span class="line">closer.Close()</span><br><span class="line"></span><br><span class="line">reader := bufio.NewReader(os.Stdin)</span><br><span class="line">_, _ = reader.ReadByte()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CreateTracer</span><span class="params">(servieName <span class="type">string</span>)</span></span> (opentracing.Tracer, io.Closer, <span class="type">error</span>) &#123;</span><br><span class="line"><span class="keyword">var</span> cfg = jaegercfg.Configuration&#123;</span><br><span class="line">ServiceName: servieName,</span><br><span class="line">Sampler: &amp;jaegercfg.SamplerConfig&#123;</span><br><span class="line">Type:  jaeger.SamplerTypeConst,</span><br><span class="line">Param: <span class="number">1</span>,</span><br><span class="line">&#125;,</span><br><span class="line">Reporter: &amp;jaegercfg.ReporterConfig&#123;</span><br><span class="line">LogSpans: <span class="literal">true</span>,</span><br><span class="line"><span class="comment">// 按实际情况替换你的 ip</span></span><br><span class="line">CollectorEndpoint: <span class="string">&quot;http://xxx:14268/api/traces&quot;</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">jLogger := jaegerlog.StdLogger</span><br><span class="line">tracer, closer, err := cfg.NewTracer(</span><br><span class="line">jaegercfg.Logger(jLogger),</span><br><span class="line">)</span><br><span class="line"><span class="keyword">return</span> tracer, closer, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 请求远程服务，获得用户信息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetUserInfo</span><span class="params">(tracer opentracing.Tracer, parentSpan opentracing.Span)</span></span> &#123;</span><br><span class="line"><span class="comment">// 继承上下文关系，创建子 span</span></span><br><span class="line">childSpan := tracer.StartSpan(</span><br><span class="line"><span class="string">&quot;B&quot;</span>,</span><br><span class="line">opentracing.ChildOf(parentSpan.Context()),</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">url := <span class="string">&quot;http://127.0.0.1:8081/Get&quot;</span></span><br><span class="line">req, _ := http.NewRequest(<span class="string">&quot;GET&quot;</span>, url, <span class="literal">nil</span>)</span><br><span class="line"><span class="comment">// 设置 tag</span></span><br><span class="line">ext.SpanKindRPCClient.Set(childSpan)</span><br><span class="line">ext.HTTPUrl.Set(childSpan, url)</span><br><span class="line">ext.HTTPMethod.Set(childSpan, <span class="string">&quot;GET&quot;</span>)</span><br><span class="line">tracer.Inject(childSpan.Context(), opentracing.HTTPHeaders, opentracing.HTTPHeadersCarrier(req.Header))</span><br><span class="line">resp, _ := http.DefaultClient.Do(req)</span><br><span class="line">_ = resp <span class="comment">// 丢掉</span></span><br><span class="line"><span class="keyword">defer</span> childSpan.Finish()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">r := gin.Default()</span><br><span class="line"><span class="comment">// 插入中间件处理</span></span><br><span class="line">r.Use(UseOpenTracing())</span><br><span class="line">r.GET(<span class="string">&quot;/Get&quot;</span>, GetUserInfo)</span><br><span class="line">r.Run(<span class="string">&quot;0.0.0.0:8081&quot;</span>) <span class="comment">// listen and serve on 0.0.0.0:8080 (for windows &quot;localhost:8080&quot;)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetUserInfo</span><span class="params">(ctx *gin.Context)</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;收到请求&quot;</span>)</span><br><span class="line">ctx.String(http.StatusOK, <span class="string">&quot;X&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CreateTracer</span><span class="params">(serviceName <span class="type">string</span>, header http.Header)</span></span> (opentracing.Tracer, opentracing.SpanContext, io.Closer, <span class="type">error</span>) &#123;</span><br><span class="line"><span class="keyword">var</span> cfg = jaegercfg.Configuration&#123;</span><br><span class="line">ServiceName: serviceName,</span><br><span class="line">Sampler: &amp;jaegercfg.SamplerConfig&#123;</span><br><span class="line">Type:  jaeger.SamplerTypeConst,</span><br><span class="line">Param: <span class="number">1</span>,</span><br><span class="line">&#125;,</span><br><span class="line">Reporter: &amp;jaegercfg.ReporterConfig&#123;</span><br><span class="line">LogSpans: <span class="literal">true</span>,</span><br><span class="line"><span class="comment">// 按实际情况替换你的 ip</span></span><br><span class="line">CollectorEndpoint: <span class="string">&quot;http://xxx:14268/api/traces&quot;</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">jLogger := jaegerlog.StdLogger</span><br><span class="line">tracer, closer, err := cfg.NewTracer(</span><br><span class="line">jaegercfg.Logger(jLogger),</span><br><span class="line">)</span><br><span class="line"><span class="comment">// 继承别的进程传递过来的上下文</span></span><br><span class="line">spanContext, _ := tracer.Extract(opentracing.HTTPHeaders,</span><br><span class="line">opentracing.HTTPHeadersCarrier(header))</span><br><span class="line"><span class="keyword">return</span> tracer, spanContext, closer, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">UseOpenTracing</span><span class="params">()</span></span> gin.HandlerFunc &#123;</span><br><span class="line">handler := <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line"><span class="comment">// 使用 opentracing.GlobalTracer() 获取全局 Tracer</span></span><br><span class="line">tracer, spanContext, closer, _ := CreateTracer(<span class="string">&quot;userInfoWebService&quot;</span>, c.Request.Header)</span><br><span class="line"><span class="keyword">defer</span> closer.Close()</span><br><span class="line"><span class="comment">// 生成依赖关系，并新建一个 span、</span></span><br><span class="line"><span class="comment">// 这里很重要，因为生成了  References []SpanReference 依赖关系</span></span><br><span class="line">startSpan := tracer.StartSpan(c.Request.URL.Path, ext.RPCServerOption(spanContext))</span><br><span class="line"><span class="keyword">defer</span> startSpan.Finish()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 记录 tag</span></span><br><span class="line"><span class="comment">// 记录请求 Url</span></span><br><span class="line">ext.HTTPUrl.Set(startSpan, c.Request.URL.Path)</span><br><span class="line"><span class="comment">// Http Method</span></span><br><span class="line">ext.HTTPMethod.Set(startSpan, c.Request.Method)</span><br><span class="line"><span class="comment">// 记录组件名称</span></span><br><span class="line">ext.Component.Set(startSpan, <span class="string">&quot;Gin-Http&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 header 中加上当前进程的上下文信息</span></span><br><span class="line">c.Request = c.Request.WithContext(opentracing.ContextWithSpan(c.Request.Context(), startSpan))</span><br><span class="line"><span class="comment">// 传递给下一个中间件</span></span><br><span class="line">c.Next()</span><br><span class="line"><span class="comment">// 继续设置 tag</span></span><br><span class="line">ext.HTTPStatusCode.Set(startSpan, <span class="type">uint16</span>(c.Writer.Status()))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> handler</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用链</p><p><img src="/%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA/%E8%B0%83%E7%94%A8%E9%93%BE.png" alt="img"></p><p>Tag信息</p><p><img src="/%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA/tag%E8%AF%A6%E7%BB%86%E4%BF%A1%E6%81%AF.png" alt="img"></p><p>参考连接 <a href="https://www.cnblogs.com/whuanle/p/14598049.html">https://www.cnblogs.com/whuanle/p/14598049.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;opentracing&quot;&gt;&lt;a href=&quot;#opentracing&quot; class=&quot;headerlink&quot; title=&quot;opentracing&quot;&gt;&lt;/a&gt;opentracing&lt;/h3&gt;&lt;h3 id=&quot;trace和span&quot;&gt;&lt;a href=&quot;#trace和s</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>零拷贝</title>
    <link href="http://example.com/%E9%9B%B6%E6%8B%B7%E8%B4%9D/"/>
    <id>http://example.com/%E9%9B%B6%E6%8B%B7%E8%B4%9D/</id>
    <published>2024-02-22T05:37:33.000Z</published>
    <updated>2024-02-22T06:12:33.201Z</updated>
    
    <content type="html"><![CDATA[<p> 为了传输 320MB 的文件，在用户缓冲区分配了 32KB 的内 存，把文件分成 1 万份传送，然而，这 32KB 是怎么来的？  </p><p> 如果用户缓冲区过 大，它就无法一次性把消息全拷贝给 socket 缓冲区；如果用户缓冲区过小，则会导致过多 的 read&#x2F;write 系统调用。  </p><p>pagecache:磁盘高速缓存</p><ul><li>在内存中取一小块空间用于存放经常访问的磁盘的数据，局部性原理。</li><li>预读技术，会读取多一些数据，提高顺序访问的性能</li></ul><p> 用 PageCache 缓存最近访问的数据，当空间不足时淘汰最久 未被访问的缓存（即 LRU 算法）。读磁盘时优先到 PageCache 中找一找，如果数据存在 便直接返回，这便大大提升了读磁盘的性能。  </p><p>普通磁盘文件<strong>读取并通过socket发送</strong>出去需要经过<strong>4次内存拷贝和4次用户态与内核态切换。</strong></p><p><img src="/%E9%9B%B6%E6%8B%B7%E8%B4%9D/%E6%97%A0%E9%9B%B6%E6%8B%B7%E8%B4%9D.png" alt="img"></p><p>零拷贝–sendfile方法</p><p>操作系统内核提供的函数实现了该功能，<strong>因为不经过用户缓冲区，要求用户不需要对磁盘读取的内容做处理。</strong></p><p>数据处理不经过用户缓冲区，减少了<strong>两次用户态到内核态的上下文切换，减少了一次内存拷贝。</strong></p><p><img src="/%E9%9B%B6%E6%8B%B7%E8%B4%9D/sendfile%E9%9B%B6%E6%8B%B7%E8%B4%9D.png" alt="img"></p><p>DMA技术下的零拷贝技术 Direct Memory Access</p><p><a href="https://www.baike.com/wikiid/3618426234596855008?from=wiki_content&prd=innerlink">DMA</a>是指外部设备不通过CPU而直接与系统内存交换数据的接口技术，再减少一次内存拷贝。</p><p><img src="/%E9%9B%B6%E6%8B%B7%E8%B4%9D/DMA%E4%B8%8E%E9%9B%B6%E6%8B%B7%E8%B4%9D.png" alt="img"></p><p>异步io</p><p>发起异步io请求后，立即返回处理其他任务，待有数据后会通知用户，然后进行数据读取。</p><p><img src="/%E9%9B%B6%E6%8B%B7%E8%B4%9D/%E5%BC%82%E6%AD%A5IO.png" alt="img"></p><p>直接io</p><ul><li>不经过pagecache的称为直接io,经过pagecache的称为缓存io。</li><li>对于磁盘，异步io仅支持直接io.</li></ul><p> 大文 件不应使用 PageCache，进而也不应使用零拷贝技术处理。</p><p>不过，零拷贝有一个缺点，就是不允许进程对文件内容作一些加工再发送，比如数据压缩后再发送。另外，当 PageCache 引发负作用时，也不能使用零拷贝，此时可以用异步 IO+直接 IO 替换。我们通常会设定一个文件大小阈值，针对大文件使用异步 IO 和直接 IO，而对小文件使用零拷贝。</p><p>大文件采用异步io+直接io的方式，不走pageCache。</p><p>小文件采用pagecache方式</p><p> 由于文件太大，文件中某一部分内容被再次访问到的概率其实非常低。这带来了 2 个问题：首先，由于 PageCache 长期被大文件占据，热点小文件就无法充分使用 PageCache，它们读起来变慢了；其次，PageCache 中的大文件没有享受到缓存的好处， 但却耗费 CPU 多拷贝到 PageCache 一次？</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt; 为了传输 320MB 的文件，在用户缓冲区分配了 32KB 的内 存，把文件分成 1 万份传送，然而，这 32KB 是怎么来的？  &lt;/p&gt;
&lt;p&gt; 如果用户缓冲区过 大，它就无法一次性把消息全拷贝给 socket 缓冲区；如果用户缓冲区过小，则会导致过多 的 read&amp;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>test1</title>
    <link href="http://example.com/test1/"/>
    <id>http://example.com/test1/</id>
    <published>2024-02-22T05:27:01.000Z</published>
    <updated>2024-02-22T05:27:20.971Z</updated>
    
    <content type="html"><![CDATA[<p>1111122222222222</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;1111122222222222&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>epoll笔记</title>
    <link href="http://example.com/epoll%E7%AC%94%E8%AE%B0/"/>
    <id>http://example.com/epoll%E7%AC%94%E8%AE%B0/</id>
    <published>2024-02-22T05:23:51.000Z</published>
    <updated>2024-02-22T05:24:09.442Z</updated>
    
    <content type="html"><![CDATA[<p>C10M 千万级连接、高性能、高并发</p><p>水平触发是只要读缓冲区有数据，就会一直触发可读信号，而边缘触发仅仅在空变为非空的时候通知一次</p><h3 id="网络事件"><a href="#网络事件" class="headerlink" title="网络事件"></a>网络事件</h3><p>处理基于 TCP 的应用层协议时，一个请求的处理代码必须被 拆分到多个回调函数中，由异步框架在相应的事件生成时调用它们。这就是事件驱动方式， 它通过减少上下文切换次数，实现了 C10M 级别的高并发。  </p><p> 读事件与写事件，其中，读事件表示有到 达的消息需要处理，而写事件表示可以发送消息（TCP 连接的写缓冲区中有可用空间）  </p><p> 多个请求复 用了一个进程，也叫做多路复用（或者叫做时分多路复用）。我们熟知的 epoll，就是内核 提供给用户态的多路复用接口，进程可以通过它从内核中获取事件。  </p><p> 当调用 write 函 数发送时，会先把内存中的数据拷贝到写缓冲区中后，再发送到网卡上。为何要多此一举呢？这是因为在对方没有明确表示收到前，TCP 会通过<strong>定时器重发写缓冲区中的数据</strong>，保证消息能够到达对方。  </p><p>tcp 与事件之间的关系</p><ul><li>在连接建立时，客户端会生成写事件write，服务端会生成读事件 accept</li><li>数据交互过程中，接受数据产生读事件，发送数据与内核缓冲区有关，有空闲缓冲区时，产生 写事件。</li><li>连接关闭时，被动关闭方会收到读事件，提醒执行close方法</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2024/png/35483742/1704186022385-57026a26-1532-4b48-9b4b-d0ec7e7a2b35.png" alt="img"></p><p><img src="https://cdn.nlark.com/yuque/0/2024/png/35483742/1704186222928-988fd529-ede5-4237-a11e-9d0b00e61ad6.png" alt="img"></p><p><img src="https://cdn.nlark.com/yuque/0/2024/png/35483742/1704186319332-dcec2a24-ff9c-4f40-84b1-c52e7bc92c29.png" alt="img"></p><p>事件回调函数处理时间要足够短。</p><ul><li>计算任务：要么把这 样的请求放在独立的线程中完成，要么把请求的处理过程拆分成多段，确保每段能够快速执 行完，同时每段执行完都要均等地处理其他事件，  </li><li>磁盘读写：写很快，write直接放到pagecache就算完成；读取大文件，分成多个小文件间隔读取。</li><li>网络请求：设置socket为非阻塞式。</li></ul><p>epoll</p><ul><li>将要监听事件的socket注册到内核。</li><li>收集事件，不用重复传递socket，节省上下文切换内存拷贝消耗。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;C10M 千万级连接、高性能、高并发&lt;/p&gt;
&lt;p&gt;水平触发是只要读缓冲区有数据，就会一直触发可读信号，而边缘触发仅仅在空变为非空的时候通知一次&lt;/p&gt;
&lt;h3 id=&quot;网络事件&quot;&gt;&lt;a href=&quot;#网络事件&quot; class=&quot;headerlink&quot; title=&quot;网络事件</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>cdn</title>
    <link href="http://example.com/cdn/"/>
    <id>http://example.com/cdn/</id>
    <published>2024-02-22T05:22:50.000Z</published>
    <updated>2024-02-22T05:23:04.393Z</updated>
    
    <content type="html"><![CDATA[<p>内容分发网络（CDN）通过在多个地理位置建立一个入网点（PoP）或一组 CDN 边缘服务器来工作。这个分布在不同地理位置的网络<strong>基于缓存、动态加速和边缘逻辑计算</strong>的原则工作。</p><h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p><a href="https://aws.amazon.com/caching/cdn/">CDN 中的缓存</a>的工作原理如下：</p><ol><li>来自偏远地理位置的网站访客首次从您的网站请求静态 Web 内容。</li><li>请求到达您的 Web 应用程序服务器或原始服务器。原始服务器将响应发送给远程访客。同时，它还将响应的副本发送到与该访客地理上最近的 CDN POP。</li><li>CDN POP 服务器将副本存储为缓存文件。</li><li>下次该访客或该位置的任何其他访客发出相同的请求时，将由缓存服务器而不是原始服务器发送响应。</li></ol><h3 id="动态加速"><a href="#动态加速" class="headerlink" title="动态加速"></a>动态加速</h3><p>动态加速是指通过在 Web 应用程序和客户端之间设置中间 CDN 服务器，从而加快对动态 Web 内容请求的服务器响应。缓存不适用于动态 Web 内容，因为内容因用户请求而异。CDN 服务器必须针对每个动态请求重新连接原始服务器，但它们通过优化自己与原始服务器之间的连接加速了该过程。<strong>可能还需要花费时间打开和关闭连接以进行安全验证。另一方面，如果附近的 CDN 服务器将请求转发到原始服务器，它们就已经建立了一个持续的、受信任的连接。</strong></p><ul><li>智能路由算法</li><li>地理位置靠近原始服务器</li><li>能够处理客户端请求，缩减其大小</li></ul><h3 id="边缘逻辑计算"><a href="#边缘逻辑计算" class="headerlink" title="边缘逻辑计算"></a>边缘逻辑计算</h3><p>您可以对 CDN 边缘服务器进行编程，以执行简化客户端和服务器之间通信的逻辑计算。例如，此服务器可以执行以下操作：</p><ul><li>检查用户请求并修改缓存行为。</li><li>验证和处理不正确的用户请求。</li><li>在响应之前修改或优化内容。</li></ul><p>Web 服务器和网络边缘之间的应用程序逻辑分布有助于开发人员减轻原始服务器的计算需求并提高网站性能。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;内容分发网络（CDN）通过在多个地理位置建立一个入网点（PoP）或一组 CDN 边缘服务器来工作。这个分布在不同地理位置的网络&lt;strong&gt;基于缓存、动态加速和边缘逻辑计算&lt;/strong&gt;的原则工作。&lt;/p&gt;
&lt;h3 id=&quot;缓存&quot;&gt;&lt;a href=&quot;#缓存&quot; clas</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>test</title>
    <link href="http://example.com/test/"/>
    <id>http://example.com/test/</id>
    <published>2024-02-22T05:21:11.000Z</published>
    <updated>2024-02-22T05:21:39.170Z</updated>
    
    <content type="html"><![CDATA[<p>1111111111111111111111</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;1111111111111111111111&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://example.com/hello-world/"/>
    <id>http://example.com/hello-world/</id>
    <published>2024-02-22T03:53:35.230Z</published>
    <updated>2024-02-22T03:53:35.230Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>
