<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> wireshark使用 · 不知道的博客</title><meta name="description" content="wireshark使用 - 不知道"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://gitfei1.github.io/atom.xml" title="不知道的博客"><meta name="generator" content="Hexo 7.1.1"><link rel="alternate" href="/atom.xml" title="不知道的博客" type="application/atom+xml">
</head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/sunchongsheng" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/pinggod" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">wireshark使用</h1><div class="post-info">2024年2月29日</div><div class="post-content"><p>Wireshark 的主界面还有个特点，就是当它的 Information 列展示的是应用层信息时，这个报文的 TCP 层面的控制信息就不显示了。</p>
<p>第一个 FIN 控制报文，并没有像常规的那样单独出现，而是合并（Piggybacking）在 POST 报文里！</p>
<hr>
<p>TTL 的值是反映了网络路径跳数的，也可以通过它间接推导出对端的 OS 类型。不同的操作系统其初始 TTL 值不同，一般来说 Windows 是 128，Linux 是 64。</p>
<p>因为内网路径相对稳定，一般不会变化。如果出现 TTL 值的波动，特别是当这个波动值比较大（比如超过 2）的时候，那几乎就说明这些包的不同寻常了。这就是我想说的第二点：<strong>内网同一个连接中的报文，其 TTL 值一般不会变化。</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">抓取IP层的报文</span></span><br><span class="line">tcpdump -i eth0 -s 34</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">抓取syn报文</span></span><br><span class="line">tcpdump -i any &#x27;tcp[13]&amp;2 !=0&#x27;</span><br><span class="line">tcpdump -i any &#x27;tcp[tcpflags]&amp;tcp-syn !=0&#x27;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">直接读取抓包文件</span></span><br><span class="line">tcpdump -r file.pcap &#x27;tcp[tcpflags] &amp; (tcp-rst) != 0&#x27; </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">就是每 100MB 或者 60 分钟（满足任一条件即可）就生成一个文件，一共 10个文件：</span></span><br><span class="line">tcpdump -i eth0 -w file.pcap -W 10 -C 100 -G 60</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">nc测试udp端口22</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">用 nc 探测 UDP 端口，不通的结果是可信的，而能通（succeeded）的结果并不准确，只能作为参考。</span></span><br><span class="line">nc -v -w 2 47.94.129.219 -u 22</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">ss 查看各种状态的连接个数</span></span><br><span class="line">ss -ant | awk &#x27;&#123;++s[$1]&#125;END&#123;for(k in s) print k,s[k]&#125;&#x27;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">http压力测试，并发请求100次，总共20万请求</span></span><br><span class="line">ab -c 100 -n 200000 http://www.baidu.com/</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">衡量一台主机的网络处理能力，包量,如果增加请求量，包量依旧上不去，就是到瓶颈了</span></span><br><span class="line">sar -n DEV 1 10</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看本地端口范围，客户端连接使用，可能导致源端口不够用</span></span><br><span class="line">sysctl net.ipv4.ip_local_port_range</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">设置TIME_WAIT连接个数为100，超过的会被系统强制关闭。</span></span><br><span class="line">sysctl net.ipv4.tcp_max_tw_buckets=100</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">按照http 事务耗时过滤</span></span><br><span class="line">http.time</span><br></pre></td></tr></table></figure>



<h3 id="https明文方法"><a href="#https明文方法" class="headerlink" title="https明文方法"></a>https明文方法</h3><ol>
<li>创建一个用来存放 key 信息的日志文件，然后在系统里配置一个环境变量 <strong>SSLKEYLOGFILE</strong>，它的值就是这个文件的路径.&#x2F;my_ssl.log。</li>
<li>启动抓包程序，然后访问 HTTPS 站点，此时 TLS 密钥信息将会导出到这个日志文件，而加密报文也会随着抓包，被保存到抓包文件中。</li>
<li>在 Wireshark 里，打开 编辑-&gt;首选项-&gt;protocols 菜单，在 Protocol 列表里找到 TLS，<strong>然后把 (Pre)-Master-Secret log filename 配置为那个文件的路径my_ssl.log。</strong></li>
</ol>
<h3 id="openssl-测试https"><a href="#openssl-测试https" class="headerlink" title="openssl 测试https"></a>openssl 测试https</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">openssl s_client -connect www.baidu.com:443</span><br><span class="line">---</span><br><span class="line">GET / HTTP/1.1                     </span><br><span class="line"></span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Accept-Ranges: bytes</span><br><span class="line">Cache-Control: no-cache</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Content-Length: 9508</span><br><span class="line">Content-Type: text/html</span><br></pre></td></tr></table></figure>



<h3 id="TCP-Window-Full"><a href="#TCP-Window-Full" class="headerlink" title="TCP Window Full"></a>TCP Window Full</h3><p>TCP Window Full 这个信息非常直接明了，就是说“接收窗口满了”。不过，你可别以为这个信 息是 TCP 报文里的某个字段。其实，它只是 Wireshark 通过分析得出的信息。你有没有注意 到，TCP Window Full 前后是有方括号的。一般来说，Wireshark 自己分析得到的信息，都会 用方括号括起来，而 TCP 报文本身的字段，是不会带这种方括号的。</p>
<h3 id="获取请求源IP"><a href="#获取请求源IP" class="headerlink" title="获取请求源IP"></a>获取请求源IP</h3><ul>
<li>应用层： http头部 X-Forwarded-For，依次存放代理的源IP</li>
<li>传输层 ：TOA 全称是 TCP Option Address，它是利用 TCP Options 的字段来承载真实源 IP 信息，TCP Options 是可变长的，最长为 40 字节（ Option 项由三部分组成： op-kind； op-length； op-data）</li>
<li>Proxy Protocol：这个方案是 HAProxy（另外一个广泛应用的反向代理软件）工程师提出的。它的实现原理是 这样的：  客户端在 TCP 握手完成之后，在应用层数据发送之前，插入一个包，这个包的 payload 就 是真实源 IP。也就是说，在三次握手后，第四个包不是应用层请求，而是一个包含了真实 源 IP 信息的 TCP 包，这样应用层请求会延后一个包，从第五个包开始。 服务端也需要支持 Proxy Protocol，以此来识别三次握手后的这个额外的数据包，提取出真 实源 IP。</li>
</ul>
<h3 id="grpc-明文"><a href="#grpc-明文" class="headerlink" title="grpc 明文"></a>grpc 明文</h3><ul>
<li>确保wireshark版本3.4及以上，要支持protobuf协议</li>
<li>配置proto文件 ，编辑-&gt;首选项-&gt;protocols 菜单，在 Protocol 列表里找到 protobuf，上传proto文件并且打开选项</li>
<li>导入抓包文件到wireshark，输入grpc过滤，选中报文右键decode as-&gt;添加端口和HTTP2后点击save。</li>
</ul>
<h3 id="常用的过滤条件"><a href="#常用的过滤条件" class="headerlink" title="常用的过滤条件"></a>常用的过滤条件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">grpc.message_data contains &quot;3_0_103&quot;</span><br><span class="line">tcp contains &quot;abc&quot;</span><br><span class="line">ip contains &quot;abc&quot;</span><br><span class="line">http contains &quot;abc&quot;</span><br><span class="line"></span><br><span class="line">tcp.flags.reset eq 1 #找到RST报文</span><br><span class="line">tcp.flags.syn eq 1 #找到握手的SYN报文</span><br><span class="line">tcp.flags.fin eq 1 #找到挥手的FIN报文</span><br><span class="line"></span><br><span class="line">tcp.payload contains 61-62-63  #tcp中含有abc</span><br><span class="line">frame.time &gt;=&quot;Mar 28, 2022 00:00:00&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">C接口告警</span></span><br><span class="line">tcp.payload[12:2]==f701</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">C接口告警确认</span></span><br><span class="line">tcp.payload[12:2]==f801</span><br></pre></td></tr></table></figure>



<h3 id="丢包排查"><a href="#丢包排查" class="headerlink" title="丢包排查"></a>丢包排查</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">netstat -s | grep retransmited</span><br><span class="line">6734 segments retransmited</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">如果这个数据一致增长，代表存在丢包</span></span><br><span class="line"></span><br><span class="line">traceroute -I 192.168.4.80</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">* 代表没有响应，可能是设备就不回复ICMP端口不可达报文，带上-I参数。</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">中间路径的丢包率</span></span><br><span class="line">mtr -c 10 -r 8.8.8.8</span><br></pre></td></tr></table></figure>



<h3 id="keep-alive"><a href="#keep-alive" class="headerlink" title="keep-alive"></a>keep-alive</h3><ul>
<li>首先，对于 TCP Keep-alive，你需要掌握：默认 TCP 连接并不启用 Keep-alive，若要打开的话要显式地调用 setsockopt()，来设置保活包的发送间隔、等待时间、重试<br>  个数等配置。在全局层面，Linux 还默认有 3 个跟 Keep-alive 相关的内核配置项可以调整：tcp_Keepalive_time，tcp_Keepalive_probes，还有 tcp_Keepalive_intvl。<br>  TCP 心跳包的特点是，它的序列号是上一个包的下个序列号 -1，而心跳回复包的确认号是这个序列号 -1+1（即还是这个序列号）。 </li>
<li>然后，对于 HTTP Keep-alive 的知识点，你需要理解：HTTP&#x2F;1.0 默认是短连接，HTTP&#x2F;1.1 和 2 默认是长连接。Connection: Keep-alive 在 HTTP&#x2F;1.0 里，能起到维持长<br>  连接的作用，而在 HTTP&#x2F;1.1 里面没有这个作用（因为默认就是长连接）。Connection: Close 在 HTTP&#x2F;1.1 里，可以起到优雅关闭连接的作用。<br>  这个头部在流量调度场景下也很有用，能明显加快基于 DNS&#x2F;GSLB 的流量调整的收敛速度。</li>
</ul>
<h3 id="TLS"><a href="#TLS" class="headerlink" title="TLS"></a>TLS</h3><p>TLS 的“四大护法”。 它们的组合，就是密码套件 Cipher Suite。TLS 握手的重要任 务之一，就是找到双方共同支持的那个密码套件。</p>
<ul>
<li>密钥交换算法：保证对称密钥的交换是安全的，典型算法包括 DHE、ECDHE。 </li>
<li>身份验证和签名算法：确认服务端的身份，其实就是对证书的验证，非对称算法就用在这 里。典型算法包括 RSA、ECDSA。 </li>
<li>对称加密算法：对应用层数据进行加密，典型算法包括 AES、DES。 </li>
<li>消息完整性校验算法：确保消息不被篡改，典型算法包括 SHA1、SHA256。</li>
</ul>
<p>一个典型的密码套件： TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA（0xc013）</p>
</div></article></div></main><footer><div class="paginator"><a href="/Linux%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E5%8A%A0%E8%BD%BD%E9%A1%BA%E5%BA%8F%E5%88%86%E6%9E%90/" class="prev">PREV</a><a href="/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/" class="next">NEXT</a></div><div class="copyright"><p>© 2015 - 2024 <a href="https://gitfei1.github.io">不知道</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>